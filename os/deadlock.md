# 死锁
  ## 基本概念
  死锁: 多线程中最差的一种情况，多个线程相互占用对方的资源的锁，而又相互等对方释放锁，此时若无外力干预，这些线程则一直处理阻塞的假死状态，形成死锁。<br/>
  饥饿: 一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。<br/>
<img width="600" alt="1681017737879" src="https://user-images.githubusercontent.com/86211987/230755905-1f75a36c-ce68-4a91-bf21-d3537815518a.png"><br/>
  死锁产生的四个必要条件:<br/>
  1. 互斥条件<br/>
  2. 不剥夺条件<br/>
  3. 请求和保持条件<br/>
  4. 循环等待条件<br/>
  注: 如果同类资源只有一个，那么循环等待和死锁为必要充分条件<br/>
  ## 死锁处理
   静态策略: <br/>
    1. 破坏互斥条件: 使用SOOOLing技术<br/>
    2. 破坏不可剥夺条件(如果得不到需要资源就释放持有的[可能导致饥饿]; 如果得不到就由操作系统协助抢夺所需资源)<br/>
    3. 破坏请求和保持条件: 静态分配资源，进程一次申请完所需资源，在未全部满足前不让其投入运行(资源利用率低, 可能导致饥饿)<br/>
    4. 破坏循环等待条件: 顺序分配资源, 给资源编号, 进程需要按编号递增的顺序请求资源(不方便增加新设备，资源浪费，用户编程麻烦)<br/>
   避免死锁: <br/>
    安全序列，不安全状态和死锁: <br/>
    <img width="600" alt="1681017737879" src="https://user-images.githubusercontent.com/86211987/230758214-d9c07b7b-436b-4925-b06d-893a28643e54.png"><br/>
    银行家算法: <br/>
    <img width="600" alt="1681022744661" src="https://user-images.githubusercontent.com/86211987/230758649-7c7991ff-00b1-4d5c-a350-802771fabf4c.png">


