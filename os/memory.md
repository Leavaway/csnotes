# 内存
  内存管理: 负责内存的分配与回收; 内存空间的扩充; 地址转换; 存储保护<br/>
  外部碎片: 内存中空闲的、未分配的小块内存空间<br/>
  内部碎片: 已经被分配给某个进程，但实际上并未被使用的内存空间<br/>
  ## 内存的分配与回收
  连续分配管理方式: <br/>
    1. 单一连续分配: 只支持单道程序, 有内部碎片<br/>
    2. 固定分区分配: 支持多道程序, 有内部碎片<br/>
    3. 动态分区分配: 在进程装入内存时, 动态地创造分区, 有外部碎片(可使用紧凑技术解决)<br/>
    动态分区分配算法: <br/>
      1. <b>首次适应算法</b>: 每次都从低地址开始查找，找到第一个能满足大小的空闲分区, 可以减少小碎片<br/>
      2. 最佳适应算法: 尽可能多地留下大片空闲分区, 按容量递增次序链接; 会产生很多外部碎片<br/>
      3. 最快适应算法: 尽可能多用大片空闲分区, 按容量递减次序链接; 可以减少小碎片, 但是没有大分区留给大进程<br/>
      4. 邻近适应算法: 首次适应算法每次都从低地址开始找, 可能产生很多小的空闲分区, 而每次查找都要经过这些分区会导致查找开销增大。这个算法从上次查找结束的位置开始,但也可能导致没有大分区留给大进程<br/>
  非连续分配管理方式: <br/>
   1. 分页存储管理: 将内存空间分为一个个大小相等的分区, 每个分区就是一个"页框", 或称"页帧"。将用户进程的地址空间也按照页框大小分为页或者页面<br/>
      页号=逻辑地址/页面长度 偏移量=逻辑地址%页面长度。在计算机中页号为P, 页面偏移量为W。比如在32位操作系统中, 假设页框大小为4KB(2^12B), 那么1~20位为页号,21~32位为偏移量<br/>
      而20位页号至少需要3字节(24位来存储), 考虑到对于一个页号, 还需要存储一些相关变量比如存在位、修改位、访问位等，用于描述该页的状态和属性, 通常采用4KB作为页表项的大小。<br/>
      也就是说, 在实际查找的过程中, 比如页号3, 操作系统会使用页表基址加上3 * 4的偏移量来得到页表中页号3对应的页表项<br/>
      虚拟地址空间: <br/>
      <img width="600" alt="1681803536459" src="https://user-images.githubusercontent.com/86211987/232706467-eb8fdb01-c0f1-4914-97ab-c11355c4a59b.png"><br/>
   2. 
   3. 
 ## 地址转换
  装入:<br/>
    1. 绝对装入: 在编译时就知道程序将放到哪个位子的话，编译器将产生绝对地址的目标代码(只适用于单道处理机)<br/>
    2. 静态重定位: 在装入时对地址重定位，一次分配全部内存空间且不能移动<br/>
    3. 动态重定位: 需要一个重定位寄存器(存放装入模块存放的起始位置)<br/>
  ## 内存空间的扩充
   1. 覆盖技术(对用户不透明, 增加了用户编程负担)<br/>
   2. 交换技术: 把磁盘分为对换区(连续分配方式, 更快IO)和文件区(离散分配方式, 更高利用率)<br/>
   
