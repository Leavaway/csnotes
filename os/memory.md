# 内存
  内存管理: 负责内存的分配与回收; 内存空间的扩充; 地址转换; 存储保护<br/>
  外部碎片: 内存中空闲的、未分配的小块内存空间<br/>
  内部碎片: 已经被分配给某个进程，但实际上并未被使用的内存空间<br/>
  ## 内存的分配与回收
  连续分配管理方式: <br/>
    1. 单一连续分配: 只支持单道程序, 有内部碎片<br/>
    2. 固定分区分配: 支持多道程序, 有内部碎片<br/>
    3. 动态分区分配: 在进程装入内存时, 动态地创造分区, 有外部碎片(可使用紧凑技术解决)<br/>
    动态分区分配算法: <br/>
      1. <b>首次适应算法</b>: 每次都从低地址开始查找，找到第一个能满足大小的空闲分区, 可以减少小碎片<br/>
      2. 最佳适应算法: 尽可能多地留下大片空闲分区, 按容量递增次序链接; 会产生很多外部碎片<br/>
      3. 最快适应算法: 尽可能多用大片空闲分区, 按容量递减次序链接; 可以减少小碎片, 但是没有大分区留给大进程<br/>
      4. 邻近适应算法: 首次适应算法每次都从低地址开始找, 可能产生很多小的空闲分区, 而每次查找都要经过这些分区会导致查找开销增大。这个算法从上次查找结束的位置开始,但也可能导致没有大分区留给大进程<br/>
  非连续分配管理方式: <br/>
   1. 分页存储管理(一维): 将内存空间分为一个个大小相等的分区, 每个分区就是一个"页框", 或称"页帧"。将用户进程的地址空间也按照页框大小分为页或者页面<br/>
      页号=逻辑地址/页面长度 偏移量=逻辑地址%页面长度。在计算机中页号为P, 页面偏移量为W。比如在32位操作系统中, 假设页框大小为4KB(2^12B), 那么1到20位为页号,21到32位为偏移量<br/>
      而20位页号至少需要3字节(24位来存储), 考虑到对于一个页号, 还需要存储一些相关变量比如存在位、修改位、访问位等，用于描述该页的状态和属性, 通常采用4KB作为页表项的大小。<br/>
      也就是说, 在实际查找的过程中, 比如页号3, 操作系统会使用页表基址加上3 * 4的偏移量来得到页表中页号3对应的页表项<br/>
      页表长度: 指的是这个页表中一共有几个页表项<br/>
      页表项长度: 每个页表项占用多大的存储空间<br/>
      页面大小: 一个页面占多大的存储空间<br/>
      虚拟地址空间: <br/>
      <img width="600" alt="1681803536459" src="https://user-images.githubusercontent.com/86211987/232706467-eb8fdb01-c0f1-4914-97ab-c11355c4a59b.png"><br/>
      操作系统如何从逻辑地址得到物理地址: <br/>
      <img width="600" alt="1682322154385" src="https://user-images.githubusercontent.com/86211987/233931108-bb56a501-a7c3-4b36-b901-70a62851a8ba.png"><br/>
      快表的工作流程: <br/>
      如果快表命中, 只需要一次访存 <br/>
      <img width="600" alt="1682346732511" src="https://user-images.githubusercontent.com/86211987/234028378-44eec2bf-9296-4605-900e-65182d47b657.png"><br/>
      多级页表: 第一级页表为顶级页表, 各级页表的大小不能超过一个页面<br/> 
   2. 分段存储管理(二维): <br/> 
      <img width="600" alt="1682507709979" src="https://user-images.githubusercontent.com/86211987/234559091-f093a1f3-5f28-419a-997e-d5ac9fa8c816.png"><br/> 
      优点: 相比于分页存储的流程多了一个比较段内地址和段长的越界检查, 并且分段对用户可见而分页完全是系统行为对用户不可见<br/>
      分段比分页更容易实现信息的共享和保护: 不能被修改的代码为纯代码或可重入代码(不属于临界资源), 这样的代码可以共享，可修改的代码如有多个变量则不能共享<br/>
      而在分页中，因为页面不是按逻辑模块划分的, 这就很难实现共享<br/>
      缺点: 如果段长过大, 分配很大的连续空间会很不方便, 另外段式管理会产生外部碎片(可以使用紧凑解决, 但是需要付出较大的时间代价)<br/>
   3. 段页式存储管理: <br/> 
      <img width="600" alt="1682509205576" src="https://user-images.githubusercontent.com/86211987/234563946-f467c13f-fef5-425d-898d-f154c42dfd13.png"><br/> 

 ## 地址转换
  装入:<br/>
    1. 绝对装入: 在编译时就知道程序将放到哪个位子的话，编译器将产生绝对地址的目标代码(只适用于单道处理机)<br/>
    2. 静态重定位: 在装入时对地址重定位，一次分配全部内存空间且不能移动<br/>
    3. 动态重定位: 需要一个重定位寄存器(存放装入模块存放的起始位置)<br/>
  ## 内存空间的扩充
   1. 覆盖技术(对用户不透明, 增加了用户编程负担)<br/>
   2. 交换技术: 把磁盘分为对换区(连续分配方式, 更快IO)和文件区(离散分配方式, 更高利用率)<br/>
   3. 虚拟内存: 为了解决传统存储方式的问题比如一次性, 驻留性。根据时间局部性和空间局部性<br/>
        主要特征: 多次性 对换性 虚拟性<br/>
        为了实现虚拟内存技术, 在原有的传统非连续分配存储管理的基础上, 操作系统还增加了请求调页/段, 页面/段置换的功能<br/>
        1) 请求分页: 在页表中增加了状态位, 访问字段, 修改位, 外存地址<br/>
        <img width="600" alt="1682512283315" src="https://user-images.githubusercontent.com/86211987/234575387-7ded8a3e-82ac-498c-b0ed-1b58ac1bf2f4.png"><br/>
        快表tips: 一般来说只改快表中的数据, 只有要将快表项删除时才需要写回内存中的慢表, 这样可以减少访存次数<br/>
        页面从外存调入内存后, 需要修改慢表, 同时也需要将表项复制到表中然后再从头开始<br/>
        页面置换算法: <br/>
          1) 最佳置换算法(OPT): 选择以后永不使用或者在最长时间内不再被访问的页面淘汰; 可以保证最低的缺页率, 但实际上只有在进程执行的过程中才能知道接下来会访问到的是哪个页面, 操作系统无法提前预判页面访问序列, 因为无法实现<br/>
          2) 先进先出置换算法(FIFO): 先淘汰最早进入内存的页面; 有belady异常, 实现简单但是算法性能差<br/>
          3) 最近最久未使用置换算法(LRU):  淘汰最近最久未使用的页面; 性能好但是实现困难, 开销大<br/>
          4) 时钟置换算法(CLOCK/NRU): 最近未用算法, 简单型: 设置一个指针指向循环页面的第一个元素, 设置一圈页面的访问位0然后在访问过后设置为1, 在需要淘汰一个页面时, 当前指针指向页面如果是0则淘汰换掉, 如果是1就设为0指向下一个<br/>
               改进型: 增加了一个修改位, 0则为没被修改过, 1则为被修改过<br/>
               改进型最多会进行四轮扫描: [第一个为访问位, 第二个为修改位]一、替换第一个0 0 不修改标志位 二、替换第一个0 1 把扫描过的帧访问位设为0 三、替换第一个0 0 不修改标志位 四、替换第一个0 1<br/>
          <img width="600" alt="1682525571304" src="https://user-images.githubusercontent.com/86211987/234636880-79664daf-5fd0-4acc-ac27-eca68dd27ecd.png"><br/>

