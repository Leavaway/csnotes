## 字长(word size)
  每个计算机都有字长, 指明指针数据的标称大小(nominal size) 字长决定了虚拟地址空间的最大大小<br/>
## 浮点数操作
  概念: 反码 原码的符号位不变, 其余位取反   补码: 反码+1  变形补码: 正数00 负数11 如果两数相加 变形补码为01或者10则发生溢出<br/>
  两个64位浮点数不能直接按位相加，因为它们遵循IEEE 754标准，需要遵循特定的步骤来进行加法运算。<br/>
  对于两个64位浮点数的加法，需要遵循以下步骤：<br/>
    首先检查两个数的符号位。如果它们的符号位不同，那么实际上是在执行减法运算。在这种情况下，需要比较两个数的绝对值，以确定哪个数较大，然后根据需要交换操作数。<br/>
    对两个数的指数进行对齐。这意味着将较小数的尾数右移，使其指数与较大数的指数相同。在这个过程中，可能需要对尾数进行舍入。<br/>
    将对齐后的尾数相加。这一步可能会导致进位，需要调整指数和尾数。<br/>
    根据需要对结果进行舍入。如果结果超出了浮点数表示的范围，可能需要进行上溢或下溢处理。<br/>
    组合结果的符号位、指数和尾数，得到最终的64位浮点数表示。<br/>
  例: 假设我们要将以下两个双精度浮点数相加:<br/>
      A: 0.625<br/>
      B: 12.5<br/>
首先，将这两个数转换为IEEE 754标准的单精度浮点数表示形式: 0.625 = 1.01 * 2^(-1)   12.5 = 1.1001 * 2^3<br/>
对阶: A-> 0.000101 * 2^3  然后将A B相加 为1.101001, 按照指数3后移3位为1101.001 转化为十进制为13.125<br/>
更详细内容请参考: https://www.cnblogs.com/yilang/p/11277201.html<br/>
<br/>
<br/><br/><br/><br/>

