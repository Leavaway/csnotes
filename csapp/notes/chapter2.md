## 字长(word size)
  每个计算机都有字长, 指明指针数据的标称大小(nominal size) 字长决定了虚拟地址空间的最大大小<br/>
  ### 大小端
    #include <iostream>

      typedef unsigned char *byte_pointer;

      void show_bytes(byte_pointer start,size_t len) {
          size_t i;
          for (i=0;i< len; i++){
              printf(" %.2x", start[i]);
          }
          printf("\n");
      }

    int main()
    {
        int val = 0x87654321;
        byte_pointer valp = (byte_pointer) &val;

        std::cout << static_cast<void*>(valp) << std::endl;
        show_bytes(valp,1);
        show_bytes(valp,2);
        show_bytes(valp,3);
        return 0;
    }
 以上代码在不同字节序的系统中获得的结果不同<br/>
## 整数表示
  ### 无符号数的编码
  <img width="600" alt="1683442470865" src="https://user-images.githubusercontent.com/86211987/236662590-de67257d-04e5-4a31-bdad-a003ad086e9b.png"><br/>
  ### 补码编码
  概念: 反码 原码的符号位不变, 其余位取反   补码: 用于有符号整数的表示。对于正数，补码与原码相同；对于负数，补码为反码+1  变形补码: 正数00 负数11 如果两数相加 变形补码为01或者10则发生溢出<br/>
  <br/>

## 浮点数操作
  两个64位浮点数不能直接按位相加，因为它们遵循IEEE 754标准，需要遵循特定的步骤来进行加法运算。<br/>
  对于两个64位浮点数的加法，需要遵循以下步骤：<br/>
    首先检查两个数的符号位。如果它们的符号位不同，那么实际上是在执行减法运算。在这种情况下，需要比较两个数的绝对值，以确定哪个数较大，然后根据需要交换操作数。<br/>
    对两个数的指数进行对齐。这意味着将较小数的尾数右移，使其指数与较大数的指数相同。在这个过程中，可能需要对尾数进行舍入。<br/>
    将对齐后的尾数相加。这一步可能会导致进位，需要调整指数和尾数。<br/>
    根据需要对结果进行舍入。如果结果超出了浮点数表示的范围，可能需要进行上溢或下溢处理。<br/>
    组合结果的符号位、指数和尾数，得到最终的64位浮点数表示。<br/>
  例: 假设我们要将以下两个双精度浮点数相加:<br/>
      A: 0.625<br/>
      B: 12.5<br/>
首先，将这两个数转换为IEEE 754标准的单精度浮点数表示形式: 0.625 = 1.01 * 2^(-1)   12.5 = 1.1001 * 2^3<br/>
对阶: A-> 0.000101 * 2^3  然后将A B相加 为1.101001, 按照指数3后移3位为1101.001 转化为十进制为13.125<br/>
更详细内容请参考: https://www.cnblogs.com/yilang/p/11277201.html<br/>
## C语言中的运算
  ### 逻辑运算
  &：按位与（Bitwise AND）运算符, 按位与运算符用于对整数类型的数据进行按位运算。它将每个操作数的位进行比较，当两个相应的位都为1时，结果的相应位才为1，否则为0<br/>
  &&：逻辑与（Logical AND）运算符, 逻辑与运算符用于对布尔表达式进行逻辑运算。当且仅当两个布尔表达式都为true时，结果才为true，否则为false。逻辑与运算符具有短路行为，即如果第一个操作数为false，则无需计算第二个操作数，因为结果已确定为false<br/>
  |和||同理<br/>
  ### 逻辑运算
  左移 << 左移运算符（<<）将一个整数的二进制表示向左移动指定的位数，右侧用0填充<br/>
  右移 >> 右移运算符（>>）将一个整数的二进制表示向右移动指定的位数。对于无符号整数，左侧用0填充；对于有符号整数，左侧填充的值取决于编译器实现，通常为符号位的扩展（算术右移）或用0填充（逻辑右移）<br/>
  ### 有符号数和无符号数之间的转换
  有符号数和无符号数之间的转换是隐式的，可以通过类型转换（强制类型转换）来实现。但是，需要注意这种转换会保留二进制表示，而不是改变底层的位模式。这意味着，尽管二进制表示不变，但转换后的数值可能会发生变化<br/>
  


